var HelperNamespace = (function () {
  /**
   * @desc Build a list of all the files that are children of a directory
   * @param {string} dir The directory to search
   * @param {list} filelist The list of the directories/files already detected
   * @param {string} ext The extension to filter for the files
   */
  function walkSync(dir, filelist, ext) {
    var path = path || require('path');
    var fs = fs || require('fs'),
      files = fs.readdirSync(dir);
    filelist = filelist || [];
    files.forEach(function (file) {
      if (fs.statSync(path.join(dir, file)).isDirectory()) {
        filelist = walkSync(path.join(dir, file), filelist, ext);
      }
      else {
        if (file.indexOf(ext) > 0)
          filelist.push(path.join(dir, file));
      }
    });
    return filelist;
  }

  /**
   * @desc search in the file in parameter to detect the tags
   */
  function searchInFile(path, regex) {
    var fs = fs || require('fs');
    // load the file
    var fileContent = fs.readFileSync(path, 'utf8');
    var strArray = [];
    // match all the groups
    var match = regex.exec(fileContent);
    while (match != null) {
      strArray.push(match[1].replace(/\s+/g, ' '));
      match = regex.exec(fileContent);
    }
    return strArray;
  }

  /** Locale-aware sort */
  function localeSort(a, b) { return a.localeCompare(b); }

  // '.t("")' or '{t("")' or ' t("")' or '(t("")' or '[t("")'
  // '.t(``)' or '{t(``)' or ' t(``)' or '(t(``)' or '[t(``)'
  // Also finds ' t("some {{data}}", \n {data})'
  var T_REGEX = /[.{[(\s]t\(["`]([\w\s{}().,:'\-=\\?\/%!]*)["`],*\s*.*\)/g;

  // '``'
  var C_REGEX = /[`]([\w\s{}().,:'\-=\\?"+!]*)[`].*/g;

  /** Some additional phrases the regex can't find. */
  const EXTRA_TAGS = [
    "Fun", "Warn", "Controls", "Device", "Farm Designer", "on",
    "Map Points", "Spread", "Row Spacing", "Height", "Taxon",
    "Growing Degree Days", "Svg Icon", "Invalid date", "yes"
  ];

  /**
   * Get all the tags in the files with extension .ts of the current project
   */
  function getAllTags() {
    const srcPath = __dirname + '/../../../frontend';

    var listFilteredFiles = walkSync(srcPath, [], '.ts');
    var allTags = listFilteredFiles.map(function (x) {
      return searchInFile(x, T_REGEX);
    });
    var constantsTags = searchInFile(srcPath + '/constants.ts', C_REGEX);
    const DIAG_MESSAGE_FILE = '/devices/connectivity/diagnostic_messages.ts';
    var diagnosticTags = searchInFile(srcPath + DIAG_MESSAGE_FILE, C_REGEX);

    // flatten list of list in a simple list
    var flatAllTags = [].concat.apply([], allTags);
    var flatConstantsTags = [].concat.apply([], constantsTags);
    var flatDiagnosticTags = [].concat.apply([], diagnosticTags);
    var flatExtraTags = [].concat.apply([], EXTRA_TAGS);
    var flattenedTags = [].concat.apply([],
      [flatAllTags, flatConstantsTags, flatDiagnosticTags, flatExtraTags]);

    // distinct
    var uniq = Array.from(new Set(flattenedTags));

    var sorted = uniq.sort(localeSort);

    return sorted;
  }

  /**
   * For debugging
   */
  function logAllTags() {
    console.dir(getAllTags());
  }

  /** For debugging. Replace all translations with a debug string. */
  function replaceWithDebugString(key, debugString, debugStringOption) {
    const debugChar = debugString[0];
    switch (debugStringOption) {
      case 'r': return debugString; // replace with: string as provided
      case 's': return debugChar; // single character
      case 'n': return key.replace(/\S/g, debugChar); // maintain whitespace
      case 'l': return debugChar.repeat(key.length); // replace whitespace
      default: return key;
    }
  }

  var metrics = [];
  /** Generate translation summary data for all languages. */
  function generateMetrics() {
    var languageCodes = walkSync(__dirname, [], '.js')
      .filter(function (s) { return !s.includes('en.js'); })
      .filter(function (s) { return !s.includes('_helper.js'); })
      .filter(function (s) { return !(s.includes('.json') || s.includes('.md')); })
      .map(function (s) { return s.slice(-5, -3); });
    var fs = fs || require('fs');
    var markdown = '';
    languageCodes.map(function (lang) {
      return createOrUpdateTranslationFile(lang, true);
    });
    // var jsonMetrics = JSON.stringify(metrics, undefined, 2);
    // fs.writeFileSync(__dirname + '/metrics.json', jsonMetrics);
    markdown += '# Translation summary\n\n';
    markdown += '_This summary was automatically generated by running the';
    markdown += ' language helper:_\n\n';
    markdown += '```bash\nnode public/app-resources/languages/_helper.js\n```\n\n';
    markdown += 'Total number of phrases identified by the language helper';
    markdown += ' for translation: __';
    markdown += metrics[0].current + '__\n\n';
    markdown += '|Language|Percent translated';
    markdown += '|Phrases Translated|Other Phrases|\n';
    markdown += '|:---:|---:|---:|---:|\n';
    metrics.map(function (langMetrics) {
      markdown += '|' + langMetrics.language;
      markdown += '|' + langMetrics.percent + '%';
      markdown += '|' + langMetrics.translated;
      markdown += '|' + langMetrics.orphans;
      markdown += '|\n';
    });
    fs.writeFileSync(__dirname + '/translation_metrics.md', markdown);
  }

  /**
   * Label a section of tags with a comment before the first tag in the section.
   */
  function labelTags(string, tags, label) {
    var firstUnusedKey = Object.keys(tags)[0];
    var replacement = '\n  // ' + label + '\n  "' + firstUnusedKey + '"';
    var labeledString = string.replace('"' + firstUnusedKey + '"', replacement);
    return labeledString;
  }

  /** Print some translation file status metrics. */
  function generateSummary(args) {
    // {foundTags, unmatchedTags, allTags, countTranslated, countExisting, langCode}
    const current = Object.keys(args.foundTags).length;
    const orphans = Object.keys(args.unmatchedTags).length;
    const total = Object.keys(args.allTags).length;
    const percent = Math.round(args.countTranslated / current * 100);
    const existingUntranslated = args.countExisting - args.countTranslated;
    if (!args.metricsOnly) {
      console.log(current + ' strings found.');
      console.log('  ' + args.countExisting + ' existing items match.');
      console.log('    ' + args.countTranslated + ' existing translations match.');
      console.log('    ' + existingUntranslated + ' existing untranslated items.');
      console.log('  ' + (current - args.countExisting) + ' new items added.');
      console.log(percent + '% of found strings translated.');
      console.log(orphans + ' unused, outdated, or extra items.');
      console.log('Updated file (' + args.langCode + '.js) with ' + total + ' items.');
    }
    return { percent: percent, orphans: orphans, total: total, current: current };
  }

  /**
   * Create the translation file or update it with new tags
   * The tags are in the following order:
   * 1. New tags in English that need to be translated (ASC)
   * 2. Tags already translated that match an existing tag in src (ASC)
   * 3. Tags already in the file before but not found at the moment in src (ASC)
   * @param {string} lang The short name of the language.
   */
  function createOrUpdateTranslationFile(lang, metricsOnly) {
    lang = lang || 'en';

    // check current file entry
    const langFilePath = __dirname + '/' + lang + '.js';
    var fs = fs || require('fs');

    try {
      var columnsResult = HelperNamespace.getAllTags();

      var jsonCurrentTagData = {};
      columnsResult.forEach(function (column) {
        jsonCurrentTagData[column] = column;
      });

      var ordered = {};
      var fileContent;
      try {
        // check the file can be opened
        var stats = fs.statSync(langFilePath);

        // load the file
        var fileContent = fs.readFileSync(langFilePath, 'utf8');
        if (lang == 'en') {
          console.log('Current file (' + lang + '.js) content: ');
          console.log(fileContent);
          console.log('Try entering a language code.');
          console.log('For example: node _helper.js en');
          if (!metricsOnly) { generateMetrics(); }
          return;
        }
      }
      catch (e) {
        if (!metricsOnly) {
          console.log('we will create the file: ' + langFilePath);
        }
        // If there is no current file, we will create it
      }

      try {
        if (fileContent != undefined) {
          var jsonContent = fileContent
            .replace('module.exports = ', '')
            // regex to delete all comments // and :* in the JSON file
            .replace(/(\/\*(\n|\r|.)*\*\/)|(\/\/.*(\n|\r))/g, '');

          var jsonParsed = JSON.parse(jsonContent);
          const count = Object.keys(jsonParsed).length;
          if (!metricsOnly) {
            console.log('Loaded file ' + lang + '.js with ' + count + ' items.');
          }

          Object.keys(jsonParsed).sort().forEach(function (key) {
            ordered[key] = jsonParsed[key];
          });
        }
      } catch (e) {
        if (!metricsOnly) {
          console.log('file: ' + langFilePath + ' contains an error: ' + e);
        }
        // If there is an error with the current file content, abort
        return;
      }

      // For debugging
      const debug = process.argv[3];
      const debugOption = process.argv[4];

      // merge new tags with existing translation
      var result = {};
      var unexistingTag = {};
      var existing = 0;
      var translated = 0;
      // all current tags in English
      Object.keys(jsonCurrentTagData).sort(localeSort).map(function (key) {
        result[key] = jsonCurrentTagData[key];
        if (debug) {
          result[key] = replaceWithDebugString(key, debug, debugOption);
        }
      });
      for (var key in ordered) {
        // replace current tag with an existing translation
        if (result.hasOwnProperty(key)) {
          delete result[key];
          result[key] = ordered[key];
          if (debug) {
            result[key] = replaceWithDebugString(key, debug, debugOption);
          }
          existing++;
          if (key !== result[key]) { translated++; }
        }
        // if the tag doesn't exist but a translation exists,
        // put the key/value at the end of the json
        else {
          unexistingTag[key] = ordered[key];
        }
      }
      for (var key in unexistingTag) result[key] = unexistingTag[key];

      var summaryData = generateSummary({
        langCode: lang, allTags: result,
        foundTags: jsonCurrentTagData, unmatchedTags: unexistingTag,
        countTranslated: translated, countExisting: existing,
        metricsOnly: metricsOnly
      });

      var stringJson = JSON.stringify(result, null, 2);
      var label = 'Unmatched (English phrase outdated or manually added)';
      var labeledStringJson = labelTags(stringJson, unexistingTag, label);
      var newFileContent = 'module.exports = ' + labeledStringJson;

      if (!metricsOnly) {
        fs.writeFileSync(langFilePath, newFileContent);
      }
    } catch (e) {
      if (!metricsOnly) {
        console.log('file: ' + langFilePath + '. error append: ' + e);
      }
    }
    if (!metricsOnly) {
      generateMetrics();
    } else {
      summaryData.language = lang;
      summaryData.translated = translated;
      metrics.push(summaryData);
    }
  }

  // public functions
  return {
    logAllTags: logAllTags,
    getAllTags: getAllTags,
    createOrUpdateTranslationFile: createOrUpdateTranslationFile
  };
})();

// Need to run this cmd in this folder: node _helper.js
var language = process.argv[2];
HelperNamespace.createOrUpdateTranslationFile(language, false);
